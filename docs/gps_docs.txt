
Recommended Minimum data
$GPRMC,083559.00,A,4717.11437,N,00833.91522,E,0.004,77.52,091202,,,A*57
$GPRMC,         
083559.00,      UTC time, see note on UTC representation
A,              Status, V = Navigation receiver warning, A = Data valid, see position fix flags description
4717.11437,     Latitude (degrees & minutes), see format description
N,              North/South indicator
00833.91522,    Longitude (degrees & minutes), see format description
E,              East/West indicator
0.004,          Speed over ground
77.52,          Course over ground
091202,         Date in day, month, year format, see note on UTC representation
,               Magnetic variation value (blank - not supported)
,               Magnetic variation E/W indicator (blank - not supported)
A               Mode Indicator, see position fix flags description
*57             

Global positioning system fix data
$GPGGA,092725.00,4717.11399,N,00833.91590,E,1,08,1.01,499.6,M,48.0,M,,*5B
$GPGGA,
092725.00,      time
4717.11399,     lat
N,              NS
00833.91590,    long
E,              EW
1,              quality
08,             numSV, Number of satellites used (range: 0-12)
1.01,           Horizontal Dilution of Precision
499.6,          Altitude above mean sea level
M,              Altitude units: meters (fixed field)
48.0,           Geoid separation: difference between geoid and mean sea level
M,              Separation units: meters (fixed field)
,               Age of differential corrections (blank when DGPS is not used)
*5B             Checksum
<CR><LF>        Carriage return and line feed  


Course over ground and Ground speed
$GPVTG,77.52,T,,M,0.004,N,0.008,K,A*06
$GPVTG,
77.52,          Course over ground (true)
T,              Fixed field: true
,               Course over ground (magnetic), not output
M,              Fixed field: magnetic
0.004,          Speed over ground (knot = sea mile per hour = 0.514444444 м / с )
N,              Fixed field: knots
0.008,          Speed over ground
K,              Fixed field: kilometers per hour
A               Mode Indicator, see position fix flags description
*06             Checksum
<CR><LF>        Carriage return and line feed  

  
  //Disable data that we don't need.
  Serial.println("$PUBX disable GLL....");
  Serial1.print("$PUBX,40,GLL,0,0,0,0*5C\r\n");
  Serial.println("$PUBX disable ZDA....");
  Serial1.print("$PUBX,40,ZDA,0,0,0,0*44\r\n");
  Serial.println("$PUBX disable VTG....");
  Serial1.print("$PUBX,40,VTG,0,0,0,0*5E\r\n");
  Serial.println("$PUBX disable GSV....");
  Serial1.print("$PUBX,40,GSV,0,0,0,0*59\r\n");
  Serial.println("$PUBX disable GSA....");
  Serial1.print("$PUBX,40,GSA,0,0,0,0*4E\r\n");
  Serial.println("$PUBX disable RMC....");
  Serial1.print("$PUBX,40,RMC,0,0,0,0*47\r\n");
  Serial.println("$PUBX disable GGA....");
  Serial1.print("$PUBX,40,GGA,0,0,0,0*5A\r\n");
  
  
  Enable UBX input and output on UART1 @ 115200 from NMEA mode:
  $PUBX,41,1,0003,0003,115200,0*1C\r\n

  
  
  
  
  const  uint32_t init_speed[5] = { 9600, 19200, 38400, 57600, 115200 };
...
void UbloxForceBaud(uint32_t baud)
{
    uint8_t i;
    for (i = 0; i < 5; i++)
    {
        delay(50);
        uart2ChangeBaud(init_speed[i]);
        delay(250);
        switch(baud)
        {
        case 19200:
            gpsPrint("$PUBX,41,1,0003,0001,19200,0*23\r\n");
            break;
        case 38400:
            gpsPrint("$PUBX,41,1,0003,0001,38400,0*26\r\n");
            break;
        case 57600:
            gpsPrint("$PUBX,41,1,0003,0001,57600,0*2D\r\n");
            break;
        case 115200:
            gpsPrint("$PUBX,41,1,0003,0001,115200,0*1E\r\n");
            break;
        }
    }
    uart2ChangeBaud(baud);
    delay(200);
}

static void gpsPrint(const char *str)
{
    while (*str)
    {
        delay(7);
        uart2Write(*str);
        str++;
    }
    while (!uart2TransmitEmpty());                                                  // wait to send all
    delay(30);
}

#include <NewSoftSerial.h>
NewSoftSerial ss(2, 3);

void setup()
{
  Serial.begin(9600);
  ss.begin(9600);
  delay(3000);
   delay(3000);
  ss.println("$PUBX,41,1,0003,96,0,0*14");//on
  // Set the navigation mode (Airborne, 1G)  top line 
  // Set the navigation mode (pedestrian) bottom line
   Serial.print("Setting uBlox nav mode: ");
   uint8_t setNav[] = //{0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xDC};// airbourne
                        {0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x76}; //pedestrian
//sendUBX(setNav, sizeof(setNav)/sizeof(uint8_t)); //this polls the message
   //getUBX_ACK(setNav);  leave commented  

  ss.println("$PUBX,40,GLL,0,1,0,0*5D");//on
// ss.println("$PUBX,40,GLL,0,0,0,0*5C");//off
  //----------------------------------------
ss.println("$PUBX,40,GGA,0,1,0,0*5B");//on
// ss.println("$PUBX,40,GGA,0,0,0,0*5A");//off
  //------------------------------------------
  ss.println("$PUBX,40,GSA,0,1,0,0*4F");//on
// ss.println("$PUBX,40,GSA,0,0,0,0*4E");//off
//------------------------------------------------
  ss.println("$PUBX,40,RMC,0,1,0,0*46");//on
// ss.println("$PUBX,40,RMC,0,0,0,0*47");//off
//------------------------------------------------
  ss.println("$PUBX,40,GSV,0,1,0,0*58");//on
    // ss.println("$PUBX,40,GSV,0,0,0,0*59");//off
//---------------------------------------
   ss.println("$PUBX,40,VTG,0,1,0,0*5F");//on
// ss.println("$PUBX,40,VTG,0,0,0,0*5E");//off
delay(3000); 
  }

void loop()
{ // For one second we parse GPS data and report some key values
  for (unsigned long start = millis(); millis() - start < 1000;)
  {
    while (ss.available())
    {
      char c = ss.read();
      
       Serial.write(c); // uncomment this line if you want to see the GPS data flowing
    //  if (gps.encode(c)) // Did a new valid sentence come in?
       // newData = true;
       
    }
}
}
  
0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xDC    
  
0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06,
 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00,
 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C,
 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xDC  
  
B56206242400FFFF060300000000102700000500FA00FA0064002C01000000000000000000000000000016DC  
  
0xB5, Sync Char 1
0x62, Sync Char 2
0x06, Class (CFG 0x06 Configuration Input Messages: Set Dynamic Model, Set DOP Mask, Set Baud Rate, etc.)
0x24, ID
0x24, Length LSB
0x00, Length MSB

0000    0xFF, Parameters Bitmask. 
0001    0xFF, Only the masked(Bitfield 2 bytes)
0002    0x06, Dynamic Platform model: 6 Airborne with <1g Acceleration
0003    0x03, Position Fixing Mode.   3: Auto 2D/3D
0004    0x00, Fixed altitude (mean sea level) for 2D fix mode. I4, m
0005    0x00, -
0006    0x00, -
0007    0x00, -
0008    0x10, Fixed altitude variance for 2D mode. U4 m^2
0009    0x27, -
0010    0x00, -
0011    0x00, -
0012    0x05, Minimum Elevation for a GNSS satellite to be used in NAV 
0013    0x00, Reserved
0014    0xFA, Position DOP Mask to use
0015    0x00, -
0016    0xFA, Time DOP Mask to use
0017    0x00, -
0018    0x64, Position Accuracy Mask
0019    0x00, -
0020    0x2C, Time Accuracy Mask
0021    0x01, -
0022    0x00, Static hold threshold
0023    0x00, DGPS time-out
0024    0x00, Number of satellites required to have C/N0 above cnoThresh for a fix to be attempted
0025    0x00, C/N0 threshold for deciding whether to attempt a fix
0026    0x00, Always set to zero
0027    0x00, -
0028    0x00, Always set to zero
0029    0x00, -
0030    0x00, -
0031    0x00, -
0032    0x00, Always set to zero 
0033    0x00, -
0034    0x00, -
0035    0x00, -

0x16, 
0xDC



https://github.com/cuspaceflight/joey-m/blob/master/firmware/gps.c

void gps_get_position(int32_t* lat, int32_t* lon, int32_t* alt)
{
    // Request a NAV-POSLLH message from the GPS
    uint8_t request[8] = {0xB5, 0x62, 0x01, 0x02, 0x00, 0x00, 0x03,
        0x0A};

B56201020000030A

get time
B562012100002267
answer
B5
62
01
21  NAV-TIMEUTC (0x01 0x21)
14  length LSB 
00  MSB

0000 D8     GPS time of week of the navigation epoch. See the description of iTOW for details. ms
0001 E5     -
0002 3C     -
0003 00     -
0004 FF     Time accuracy estimate (UTC) ns
0005 FF     -
0006 FF     -
0007 FF     -
0008 00     Fraction of second, range -1e9 .. 1e9 (UTC) ns
0009 00     -
0010 00     -
0011 00     -
0012 BC     Year, range 1999..2099 (UTC) 
0013 07     -
0014 01     Month, range 1..12 (UTC)
0015 06     Day of month, range 1..31 (UTC)      day
0016 01     Hour of day, range 0..23 (UTC)       hour
0017 06     Minute of hour, range 0..59 (UTC)    minute          
0018 0F     Seconds of minute, range 0..60 (UTC) sec
0019 00     Validity Flags (see graphic below)
0B     crc CK_A
0D     crc CK_B    


/**********************************************************************************/
https://github.com/QuadTinnakon/TK_QuadDue32bit_FullSensor/blob/master/GPSNEO7N_multi.h
https://ukhas.org.uk/guides:ublox_psm


http://www.multiwii.com/forum/viewtopic.php?f=6&t=4964
Here:
#define TIMEUTC_ON 0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x21,0x01,0x2D,0x85                            // set TIMEUTC MSG rate
B562060103000121012D85 











#define UBLOX_5HZ        0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A       // set rate to 5Hz
B56206080600C80001000100DE6A    It works!
just send it to module and NMEA string will be sent with 5 hz refresh rate.

10 Hz   0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00, 0x7A, 0x12

B562060806006400010001007A12

0xB5,0x62,
0x06,0x08,
0x06,0x00,
0xC8, ms
0x00,
0x01,
0x00,
0x01, GPS time
0x00

0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0xC2,0x01,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xBE,0x72

35.14.3 Port Configuration for UART
0xB5,0x62,  
0x06,0x00,      CFG-PRT , Port Configuration for UART

0x14,0x00,      Length 
0000    0x01,   portID
0001    0x00,   Reserved
0002    0x00,   TX ready PIN configuration
0003    0x00,
0004    0xD0,   A bit mask describing the UART mode
0005    0x08,
0006    0x00,
0007    0x00,
0008    0x00,   Baudrate in bits/second 115200 = 0x1C200
0009    0xC2,
0010    0x01,
0011    0x00,
0012    0x07,   A mask describing which input protocols are active
0013    0x00,   
0014    0x01,   A mask describing which output protocols are active.
0015    0x00,
0016    0x00,   Flags bit mask
0017    0x00,
0018    0x00,   Always set to zero
0019    0x00,
0xBE,0x72       CRC
  
  
SET 1 HZ  
B56206080600E803010001000139

  #define UBLOX_115200     0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0xC2,0x01,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xBE,0x72 //set speed to 115200
  #define UBLOX_57600      0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0xE1,0x00,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xDC,0xBD //set speed to 57600
  #define UBLOX_38400      0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0x96,0x00,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x91,0x84 //set speed to 38400
  #define UBLOX_19200      0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0x4B,0x00,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x46,0x4B //set speed to 19200
  #define UBLOX_9600       0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x80,0x25,0x00,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xA0,0xA9 //set speed to 9600

B5620600140001000000D008000000C201000700010000000000BE72
  
B5620600140001000000D0080000802500000700010000000000A0A9  
  
 Soft reset 0xB5,0x62,0x06,0x04,0xFF,0xFF,0x01,0x00,0x09,0x33
  
  B5620604FFFF01000933
  
Hard reset 0xB5,0x62,0x06,0x04,0xFF,0xFF,0x01,0x00,0x08,0x31
B5620604FFFF01000831
  
  
#define RMC_OFF    0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x04,0x00,0xFE,0x17                            // switch RMC off
  
0xB5,0x62,
0x06,0x01,
0x03,
0x00,
0xF0,
0x04,
0x00,
0xFE,0x17

 byte setGLL[] = {0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x2B};
B56206010800F001000000000001012B  
  
char RMC_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X04, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X03, 0X3F};
char VTG_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X05, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X04, 0X46};
char GSA_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X02, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X01, 0X31};
char GSV_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X03, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X02, 0X38};
char GLL_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X01, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X2A};
char GGA_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0XFF, 0X23};
char GGA_On[]  = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X00, 0X00, 0X01, 0X01, 0X00, 0X00, 0X00, 0X01, 0X2C}; B56206010800F000000101000000012C
char ZDA_Off[] = { 0XB5, 0X62, 0X06, 0X01, 0X08, 0X00, 0XF0, 0X08, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X07, 0X5B};  
  
https://ukhas.org.uk/guides:falcom_fsa03
  
  https://groups.google.com/forum/#!msg/phoenixpilot/vzbQk2NJXKo/WlIy96k1IO8J
  
	Interesting
	https://github.com/emlid/Navio/blob/master/C%2B%2B/Navio/Ublox.cpp  
    NAV_POSLLH = 0x0102,
    NAV_STATUS = 0x0103
	B562060103000102010E47	NAV POLL on
	B562060103000102000D46 	NAV POLL off
	B562060103000103010F49  STATUS on
	B562060103000103000E48  STATUS off
	

 *** uBlox 9/14/2015 3:50:14 PM = UTC: 135014.556 ***
NAV-POSLLH : B5 62 01 02 1C 00 1C 78 1E 08 40 50 89 09 DE D4 34 1D E0 93 04 00 E0 93 04 00 06 17 00 00 3C 24 00 00 69 89 
B5 62 
01 02 
1C 00 
0006    1C 78 1E 08 
0010    40 50 89 09     159993920   Longitude
0014    DE D4 34 1D     490001630   Latitude
0018    E0 93 04 00 
E0 93 04 00 
06 17 00 00     5894
3C 24 00 00     9276
69 89 

Latitude 49.000163N
Longitude 15.999392E
Altitude 300m
Heading 276
Speed 64km/h	
	
1C 78 1E 08
081E781c	
	
	

Distance, heading

import math
 
 #pi - число pi, rad - радиус сферы (Земли)
 rad = 6372795
 
 #координаты двух точек
 llat1 = 77.1539
 llong1 = -120.398
 
 llat2 = 77.1804
 llong2 = 129.55
 
 #в радианах
 lat1 = llat1*math.pi/180.
 lat2 = llat2*math.pi/180.
 long1 = llong1*math.pi/180.
 long2 = llong2*math.pi/180.
 
 #косинусы и синусы широт и разницы долгот
 cl1 = math.cos(lat1)
 cl2 = math.cos(lat2)
 sl1 = math.sin(lat1)
 sl2 = math.sin(lat2)
 delta = long2 - long1
 cdelta = math.cos(delta)
 sdelta = math.sin(delta)
 
 #вычисления длины большого круга
 y = math.sqrt(math.pow(cl2*sdelta,2)+math.pow(cl1*sl2-sl1*cl2*cdelta,2))
 x = sl1*sl2+cl1*cl2*cdelta
 ad = math.atan2(y,x)
 dist = ad*rad
 
 #вычисление начального азимута
 x = (cl1*sl2) - (sl1*cl2*cdelta)
 y = sdelta*cl2
 z = math.degrees(math.atan(-y/x))
 
 if (x < 0):
     z = z+180.
 
 z2 = (z+180.) % 360. - 180.
 z2 = - math.radians(z2)
 anglerad2 = z2 - ((2*math.pi)*math.floor((z2/(2*math.pi))) )
 angledeg = (anglerad2*180.)/math.pi
 
 print 'Distance >> %.0f' % dist, ' [meters]'
 print 'Initial bearing >> ', angledeg, '[degrees]'
    
    
    
    
    
    
    
    
    
    
    
  
